"""

    Autogenerated by ghenerate script, part of Quantarhei
    http://github.com/tmancal74/quantarhei
    Tomas Mancal, tmancal74@gmai.com

    Generated on: 2018-06-11 09:20:58

    Edit the functions below to give them desired functionality.
    In present version of `ghenerate`, no edits or replacements
    are perfomed in the feature file text.

"""
import numpy

from behave import given
from behave import when
from behave import then

import quantarhei as qr
from quantarhei.spectroscopy.twod2 import _ptypes, _processes, _signals


def _spectrum(a, b):
    
    def func(x, y, a, b):
    
        Delta = b
        #omega = 2.0*3.14159/20.0 
        
        data = numpy.zeros((len(x), len(y)))
        
        for i_x in range(len(x)):
                data[i_x, :] = a*numpy.exp(-(x[i_x]/Delta)**2)* \
                                 numpy.exp(-(y/Delta)**2)
                data[i_x, :] -= (a/2.0)*numpy.exp(-(x[i_x]/Delta)**2)* \
                                 numpy.exp(-((y-Delta)/Delta)**2)
        
        return data

    xrange = qr.ValueAxis(-50.0, 100, 1.0)
    yrange = qr.ValueAxis(-50.0, 100, 1.0)
    
    data = func(xrange.data, yrange.data, a, b)
    
    return (xrange, yrange, data)


#
# Given ...
#
@given('that I have data corresponding to individual Liouville pathways in 2D spectrum')
def step_given_1(context):
    """

        Given that I have data corresponding to individual liouville pathways in 2D spectrum

    """
    
    data_list = []
    para_list = [[1.0, 10.0], [2.0, 20.0], [0.5, 12.0],
                 [0.1, 16.0], [0.2, 8.9], [0.3, 9.0]]
    types = ["R1fs", "R2g", "R3g", "R3g", "R1fs", "R2g"]
    tags  = ["r1f1", "r2g1", "r3g1", "r3g2", "r1f2", "r2g2"]


    for pars in para_list:
        data_list.append(_spectrum(pars[0], pars[1]))
        
        
    context.data_list = data_list
    context.types = types
    context.tags = tags
    


#
# When ...
#
@when('I create a new TwoDSpectrum object')
def step_when_2(context):
    """

        When I create a new TwoDSpectrum object

    """
    context.twod = qr.TwoDSpectrum()


#
# Then ...
#
@then('I can save 2D data using type and tag')
def step_then_3(context):
    """

        Then I can save 2D data using type and tag

    """
    twod = context.twod
    
    data_list = context.data_list
    types = context.types
    tags = context.tags
    
    k_l = 0
    for (x, y, data) in data_list:
        tpp = types[k_l]
        tag = tags[k_l]
        
        if (k_l == 0):
            twod.set_axis_1(x)
            twod.set_axis_3(y)
        twod._add_data(data, resolution="pathways", dtype=tpp, tag=tag)
        
        numpy.testing.assert_allclose(twod._d__data[tpp][tag], data)
        
        k_l += 1
        


#
# And ...
#
@then('I can retrieve spectra by type and tag')
def step_then_4(context):
    """

        And I can retrieve spectra by type and tag

    """
    twod = context.twod
    twod.set_resolution("pathways")
    
    data_list = context.data_list
    types = context.types
    tags = context.tags
    
    k_l = 0
    for (x, y, data) in data_list:
        tpp = types[k_l]
        tag = tags[k_l]
        
        twod.set_data_flag([tpp, tag])
        
        retrieved_data = twod.d__data 
        
        numpy.testing.assert_allclose(retrieved_data, data)
        k_l += 1


def _get_tag_of_type(typ, tags):
    """Selects all tags of pathways of a give tag
    
    """
    return_tags = []
    for tag in tags:
        if tag[0] == typ:
            return_tags.append(tag)
    return return_tags


def _sum_pathways_to_types(twod, type):
    
    tags = twod.get_all_tags()
    
    if type in _ptypes:
        tags_of_type = _get_tag_of_type(type, tags)

        dsum = numpy.zeros((twod.xaxis.length, twod.yaxis.length),
                           dtype=qr.COMPLEX)
        for pair in tags_of_type:
            twod.set_data_flag(pair)
            try:
                data = twod.d__data
                dsum += data
            except:
                pass

    return dsum


def _sum_pathways_to_process(twod, process):

    types = _processes[process]
    dsum = numpy.zeros((twod.xaxis.length, twod.yaxis.length),
                       dtype=qr.COMPLEX)   
    for typ in types:
        #twod.set_data_flag(typ)
        #data = twod.d__data
        data = _sum_pathways_to_types(twod, typ)
        if data is not None:
            dsum += data
            
    return dsum


def _sum_pathways_to_signal(twod, signal):
    
    types = _signals[signal]
    dsum = numpy.zeros((twod.xaxis.length, twod.yaxis.length),
                       dtype=qr.COMPLEX)   
    for typ in types:
        #twod.set_data_flag(typ)
        #data = twod.d__data
        data = _sum_pathways_to_types(twod, typ)
        if data is not None:
            dsum += data

    return dsum


def _sum_pathways_to_total(twod):

    dsum = numpy.zeros((twod.xaxis.length, twod.yaxis.length),
                       dtype=qr.COMPLEX)    
    for signal in _signals:
        data = _sum_pathways_to_signal(twod, signal)
        if data is not None:
            dsum += data
            
    return dsum
    

#
# And ...
#
@then('I can retrieve sum of spectra of a given type {type}')
def step_then_5(context, type):
    """

        And I can retrieve sum of spectra of a given type {type}

    """


    # first we get data for comparison
    twod = context.twod
    
    dsum = _sum_pathways_to_types(twod, type)
    
    # here we test it without first changing the resolution
    twod.set_data_flag(type)
    
    retrieved_data = twod.d__data
    
    numpy.testing.assert_allclose(retrieved_data, dsum, atol=1.0e-5)
    

#
# And ...
#
@then('I can retrieve sum of spectra of a given process {process}')
def step_then_6(context, process):
    """

        And I can retrieve sum of spectra of a given process {process}

    """
    # first we get data for comparison
    twod = context.twod
    
    dsum = _sum_pathways_to_process(twod, process)

#    twod.set_resolution("processes")
    twod.set_data_flag(process)
    
    retrieved_data = twod.d__data
    
    numpy.testing.assert_allclose(retrieved_data, dsum)    



#
# And ...
#
@then('I can retrieve sum of spectra of a given signal {signal}')
def step_then_7(context, signal):
    """

        And I can retrieve sum of spectra of a given signal {signal}

    """
    # first we get data for comparison
    twod = context.twod
    
    dsum = _sum_pathways_to_signal(twod, signal)

#    twod.set_resolution("processes")
    twod.set_data_flag(signal)
    
    retrieved_data = twod.d__data
    
    numpy.testing.assert_allclose(retrieved_data, dsum)


#
# And ...
#
@then('I can retrieve total spectrum')
def step_then_8(context):
    """

        And I can retrieve total spectrum

    """
    # first we get data for comparison
    twod = context.twod
    
    dsum = _sum_pathways_to_total(twod)

#    twod.set_resolution("processes")
    twod.set_data_flag("total")
    
    retrieved_data = twod.d__data
    
    numpy.testing.assert_allclose(retrieved_data, dsum)

